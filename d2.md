# Claude Code — Implement Drift Retention + Deletion (Gap Closure)

## Objective
Implement **retention-period configuration per plan** and **automatic deletion/purge logic** for drift-related data in WorkflowOps, consistent with existing UI plan-gating and incident workflows.

You MUST:
- Apply **plan default retention values** (no UI customization required initially).
- Implement **server-side** retention enforcement (UI can be added after).
- Ensure the product continues to work when older drift history or payloads are purged.

---

## Plan Defaults (Authoritative)
Use these defaults when an org has no explicit retention override (initially: *no overrides supported*, just defaults):

| Plan | Drift check history | Open incidents | Closed incidents | Approval history |
|---|---:|---:|---:|---:|
| Free | 7 days | N/A | N/A | N/A |
| Pro | 30 days | never auto-purge | 180 days | 180 days |
| Agency+ | 90 days | never auto-purge | 365 days | 365 days |
| Enterprise | 180 days | never auto-purge | 7 years (2555 days) | 7 years (2555 days) |

Rules:
- **Never purge open incidents** by default.
- Closed incidents are retained per table above.
- Drift check history is **ephemeral**; keep only within window.
- For Enterprise, cap defaults to **7 years** (bounded, not infinite).

---

## Scope: What Data Must Be Retained/Purged
Identify where each is stored in your DB/models and implement retention for all:

1. **Drift check results**
   - Environment drift status (in_sync/drift/unknown), counts, last_checked timestamps
   - Workflow-level drift flags (modified/not_in_git/unknown)
2. **Incidents**
   - Incident record including status lifecycle fields (`detected`, `acknowledged`, `stabilized`, `reconciled`, `closed`)
3. **Incident payload**
   - The JSON blob shown in Incident → Drift Summary tab
4. **Approvals (Enterprise)**
   - Approval requests/decisions/notes/history for incident lifecycle actions

---

## Required Outcomes
- System automatically purges drift check history beyond retention windows.
- Closed incident data is purged/archived per plan.
- UI continues to function:
  - Env list shows badge + “Checked X ago” based on latest retained record.
  - Incident detail still loads after payload purge (shows “Details purged per retention policy”).
  - Drift dashboard metrics still work (may be derived from incidents that remain).

---

## Implementation Steps

### 1) Inventory & Map Tables/Models
Search codebase for:
- drift check persistence (tables/models)
- incident tables + lifecycle event tables
- approval tables
- any blob storage for drift payloads (DB JSON, file store, git, etc.)

Produce a mapping doc in the PR description:
- `Entity -> table -> primary timestamps used for retention`

Key timestamps required:
- drift checks: `checked_at` or similar
- incidents: `closed_at` (must exist for retention)
- approvals: `decided_at`/`created_at`
- payload: link to incident + timestamp

---

### 2) Add Missing Fields (DB Migrations)
If not already present, add:

**Incidents**
- `closed_at TIMESTAMP NULL`
- `is_deleted BOOLEAN DEFAULT FALSE` (soft-delete)
- `deleted_at TIMESTAMP NULL`
- `payload_purged_at TIMESTAMP NULL` (for “shell incident remains, payload removed”)

**Incident payload storage**
If payload is stored directly on the incident row:
- Create table `incident_payloads`:
  - `incident_id (FK, unique)`
  - `payload_json JSONB` (or TEXT)
  - `created_at TIMESTAMP`
- Migrate existing payload into this table.
Rationale: allows purging payload without deleting incident metadata.

**Drift checks**
Ensure checks are stored with:
- `env_id`
- `checked_at`
- `summary_json` (optional)
- workflow flags can be separate table keyed by check_id

---

### 3) Implement Plan Retention Resolver (Backend)
Create a single function/service used by purge jobs:

- Input: `org_id`
- Output:
  - `drift_check_retention_days`
  - `incident_closed_retention_days`
  - `approval_retention_days`

Implementation:
- Determine org plan (existing plan/entitlement system).
- Return the defaults table above.

Add unit tests for this mapping.

---

### 4) Implement Retention Purge Job (Backend Worker/Cron)
Add a scheduled job (nightly recommended) that runs per org:

**4.1 Purge drift check history**
- Delete drift check rows with `checked_at < now() - drift_check_retention_days`
- Also delete associated workflow-level drift rows keyed to those checks.
- IMPORTANT: keep enough data for UI:
  - Always retain the most recent drift check per environment (even if older than window) OR
  - Ensure the environment record itself stores `drift_status` + `last_checked_at` and is updated on each check.
Pick the approach that matches your current schema:
- If env table already has last drift status timestamps, you can fully purge old checks safely.

**4.2 Purge incident payloads (preferred)**
For incidents where:
- `status = closed` (or `closed_at IS NOT NULL`)
- `closed_at < now() - incident_closed_retention_days`
Then:
- Delete from `incident_payloads` for those incidents
- Set `payload_purged_at = now()`

**4.3 Purge closed incidents (optional, if required)**
Decide based on current needs:
- Default to **retain incident shell** (recommended) and only purge payload.
- If you must delete incidents fully, do it only if:
  - plan allows, and
  - approvals/audit constraints permit
For this task: **DO NOT hard-delete incidents**. Keep metadata; purge payload only.

**4.4 Purge approvals**
For orgs with approval tables:
- Delete approvals where `created_at < now() - approval_retention_days`
- If you need compliance for Enterprise, keep approval metadata but purge bulky fields first (notes) — only if schema supports.

**4.5 Logging/metrics**
- Log counts purged per table per org
- Persist a “purge run” record if you already have an ops/audit table (optional)

---

### 5) Make UI Resilient to Purged Payloads
Update incident detail endpoint/UI rendering to handle missing payload:

If `incident_payloads` row not found OR `payload_purged_at IS NOT NULL`:
- Show banner: “Incident drift details were purged per retention policy.”
- Keep timeline/status/actions visible (as permitted)
- Keep links to env and deployment gating

Update any API DTOs to make `drift_summary` optional.

Add integration tests:
- Incident loads with payload present
- Incident loads with payload missing

---

### 6) Add Admin “Purge Now” Endpoint (Optional but Useful)
Implement:
- `POST /orgs/{orgId}/retention/purge`
Admin-only.
Triggers same purge logic for that org (async job enqueue preferred).

This is optional, but if you have a worker framework already, it’s low effort and helpful.

---

### 7) Tests (Required)
**Unit**
- Plan -> retention mapping resolver

**Integration**
- Drift check purge removes old checks and dependent rows
- Payload purge removes blob but keeps incident metadata
- Open incidents never purged
- “Latest drift status” still available in env list (depends on your schema choice)

**UI/DTO regression**
- Incident detail renders when drift payload missing

---

## Acceptance Criteria
- After purge job runs:
  - Drift status badges still show for all environments (latest retained status).
  - Free tier does not accumulate drift check history > 7 days.
  - Pro/Agency/Enterprise drift check history respects retention windows.
  - Closed incident payloads are removed after retention window; incident still accessible.
  - No open incidents are removed/purged.
  - No runtime errors when payloads are missing.

---

## Deliverables in PR
1. Migrations added (with reversible down migrations if your process requires).
2. Retention resolver service + tests.
3. Purge job + tests.
4. Incident payload storage refactor (if needed) + migration.
5. UI/API handling for purged payloads.

---

## Constraints / Non-Goals
- No custom retention UI configuration in this iteration (plan defaults only).
- No hard-deleting incidents (metadata must remain).
- Do not change plan gating of drift incidents/dashboards; only add retention lifecycle.

